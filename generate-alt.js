/**
 * @typedef {Object} ResultMetaItem
 * @property {string} label
 * @property {string} [suffix] Optional suffix for pluralization
 */

/**
 * @typedef {Record<typeof CORRECT_KEY | typeof MISTAKE_KEY | typeof HINT_KEY | typeof DOUBLE_HINT_KEY, number>} ResultTotalsItem
 */

/**
 * Key for "CORRECT" results, denoted by 游릴
 *
 * @type {"correct"}
 */
const CORRECT_KEY = "correct";
/**
 * Key for "MISTAKE" results, denoted by 游릳
 *
 * @type {"mistake"}
 */
const MISTAKE_KEY = "mistake";
/**
 * Key for "HINT" results, denoted by 游리
 *
 * @type {"hint"}
 */
const HINT_KEY = "hint";
/**
 * Key for "DOUBLE HINT" results, denoted by 游
 *
 * @type {"doubleHint"}
 */
const DOUBLE_HINT_KEY = "doubleHint";

/**
 * Dictionary to map the icon (generated by cluesbysam) to the key (used internally)
 *
 * @type {{ "游릴": string; "游릳": string; "游리": string; "游": string; }}
 */
const iconMap = {
  "游릴": CORRECT_KEY,
  "游릳": MISTAKE_KEY,
  "游리": HINT_KEY,
  "游": DOUBLE_HINT_KEY,
};

/**
 * Visualisation metadata for each of the result types
 *
 * @type {Record<string, ResultMetaItem>}
 */
const resultsMeta = {
  [CORRECT_KEY]: { label: "correct guess", suffix: "es" },
  [MISTAKE_KEY]: { label: "mistake" },
  [HINT_KEY]: { label: "hint" },
  [DOUBLE_HINT_KEY]: { label: "double hint" },
};

/**
 * Regex to match the first line of text
 * To match:
 * * "I solved the daily Clues by Sam, Nov 17th 2025 (Easy), in 02:50"
 * * "I solved the daily Clues by Sam (Nov 14th 2025) in less than 17 minutes"
 *
 * @type {RegExp}
 */
const PREAMBLE_REGEX = /^I solved the daily Clues by Sam.*/;

/**
 * Regex to match the URL at the end of the results output
 * To match, well:
 * * "https://cluesbysam.com"
 *
 * @type {RegExp}
 */
const LINK_REGEX = /https:\/\/cluesbysam.com/;

/**
 * Description placeholder
 * To match the results as declared in cluesbysam:
 * > 游릴 means you correctly identified the person
 * > 游릳 means you made at least one mistake identifying the person
 * > 游리 means you used a hint to identify the person
 * > 游 means you used a double hint to identify the person
 * We match 8 as there are 4 per row, and the emojis count as two characters each
 *
 * @type {RegExp}
 */
const RESULT_REGEX = /[游릴游릳游리游]{8}/;

/**
 * Pluralise a string with an optional suffix
 *
 * @param {number} count
 * @param {string} noun
 * @param {string} [suffix="s"]
 * @returns {string}
 */
function pluralise(count, noun, suffix = "s") {
  return `${noun}${count !== 1 ? suffix : ""}`;
}

/**
 * Convert a ResultTotalsItem object into a readable string
 *
 * @param {ResultTotalsItem} resultsTotals
 * @returns {string}
 */
function parseResults(resultsTotals) {
  if (resultsTotals[CORRECT_KEY] === 20) {
    return "Clean sweep! All correct with no mistakes or hints.";
  }

  let parsedString;

  [CORRECT_KEY, MISTAKE_KEY, HINT_KEY, DOUBLE_HINT_KEY].forEach((key) => {
    if (resultsTotals[key]) {
      parsedString += `; ${resultsTotals[key]} ${pluralise(
        resultsTotals[key],
        resultsMeta[key].label,
        resultsMeta[key].suffix
      )}`;
    }
  });

  return parsedString;
}

/**
 * Count one row  of results into accumulator "resultTotals"
 * * mutates accumulator.
 *
 * @param {string} resultLine A line of text matching RESULT_REGEX
 * @param {ResultTotalsItem} [resultTotals={}]
 * @returns {ResultTotalsItem} The modified ResultTotalsItem with updated counts
 */
function countResults(resultLine, resultTotals = {}) {
  for (const ch of resultLine) {
    const key = iconMap[ch];

    if (!key) continue;

    resultTotals[key] = (resultTotals[key] || 0) + 1;
  }

  return resultTotals;
}

/**
 * Takes input from the user and splits it down for processing
 * Expected format:
 * > "I solved the daily Clues by Sam, Nov 17th 2025 (Easy), in 02:50\n游릴游릴游릴游릴\n游릴游릴游릴游릴\n游릴游릴游릴游릳\n游릴游릴游릴游릴\n游릴游릴游릴游릴\nhttps://cluesbysam.com"

 * @param {string} results
 * @returns {{ preamble: string; body: string; link: string; }}
 */
const generateAltText = function (results) {
  let preamble,
    body,
    link,
    resultTotals = {
      [CORRECT_KEY]: 0,
      [MISTAKE_KEY]: 0,
      [HINT_KEY]: 0,
      [DOUBLE_HINT_KEY]: 0,
    };

  results.split("\n").forEach((resultLine) => {
    if (resultLine.match(PREAMBLE_REGEX)) {
      preamble = resultLine;
      return;
    }

    if (resultLine.match(LINK_REGEX)) {
      link = resultLine;
      return;
    }

    if (resultLine.match(RESULT_REGEX)) {
      countResults(resultLine, resultTotals);
      return;
    }

    alert("Failed to process line: ", resultLine);
  });

  body = parseResults(resultTotals);

  return { preamble, body, link };
};

/**
 * Event handler for the copy button;
 * * responds to click;
 * * fetches text from the input;
 * * parses it to text using the utls above;
 * * writes it to clipboard
 *
 * @async
 * @returns {*}
 */
const handleCopyButtonClick = async function () {
  const resultsInput = document.getElementById("results-input");

  if (!resultsInput) {
    return;
  }

  const { preamble, body, link } = generateAltText(resultsInput.value);

  await navigator.clipboard.writeText(`${preamble}\n${body}\n${link}`);
};

window.pluralise = pluralise;
window.parseResults = parseResults;
window.handleCopyButtonClick = handleCopyButtonClick;
